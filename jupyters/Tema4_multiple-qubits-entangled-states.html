

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>11. Qubits Múltiples y Entangled States &#8212; Programación Cuántica</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="application/vnd.jupyter.widget-state+json">{"state": {"9f5974b9a0554348ade2870f2fc428ed": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": "0px 0px 10px 0px", "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "f681e36be1994bb686902f7c05d1bdf9": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": "0px 0px 10px 0px", "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "c807b93eb2d34f30a35be5cf46192bb6": {"model_name": "HTMLStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "StyleView", "background": null, "description_width": "", "font_size": null, "text_color": null}}, "b8cba03bf0024b338ac342329d46a745": {"model_name": "HTMLStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "StyleView", "background": null, "description_width": "", "font_size": null, "text_color": null}}, "a895e6c0b92a4629b4d0a21371adf214": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "HTMLView", "description": "", "description_allow_html": false, "layout": "IPY_MODEL_f681e36be1994bb686902f7c05d1bdf9", "placeholder": "\u200b", "style": "IPY_MODEL_b8cba03bf0024b338ac342329d46a745", "tabbable": null, "tooltip": null, "value": "<p style='font-family: IBM Plex Sans, Arial, Helvetica, sans-serif; font-size: 20px; font-weight: medium;'>Circuit Properties</p>"}}, "5e25264a7621425ab6653a7da005dcc5": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "HTMLView", "description": "", "description_allow_html": false, "layout": "IPY_MODEL_f681e36be1994bb686902f7c05d1bdf9", "placeholder": "\u200b", "style": "IPY_MODEL_b8cba03bf0024b338ac342329d46a745", "tabbable": null, "tooltip": null, "value": "<p style='font-family: IBM Plex Sans, Arial, Helvetica, sans-serif; font-size: 20px; font-weight: medium;'>Circuit Properties</p>"}}}, "version_major": 2, "version_minor": 0}</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script crossorigin="anonymous" data-jupyter-widgets-cdn="https://cdn.jsdelivr.net/npm/" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.6/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'jupyters/Tema4_multiple-qubits-entangled-states';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. Explorando la puerta CNOT-Gate" href="Tema5_phase-kickback.html" />
    <link rel="prev" title="10. Puertas cuánticas simples" href="Tema3_single-qubit-gates.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../introduccion.html">
  
  
  
  
  
    <p class="title logo__title">Programación Cuántica</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../introduccion.html">
                    Introducción
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Base teórica de la programación cuántica</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_I.html">1. Los qubits en la programación cuántica</a></li>
<li class="toctree-l1"><a class="reference internal" href="numeros_complejos.html">2. Introducción a los números complejos</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_II.html">3. Otros aspectos de los qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_III_puertasCuanticas.html">4. Puertas cuánticas</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parte_teorica_IV_algebra.html">5. Álgebra lineal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parte_teorica_V_qubitMultiple.html">6. Múltiples qubits</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Estados quanticos y qubits</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tema0_Introducci%C3%B3n.html">7. Introducción a programación cuántica</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema1_atoms-computation.html">8. Los qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema2_representing-qubit-states.html">9. Representación de los estados del qubit</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema3_single-qubit-gates.html">10. Puertas cuánticas para un qubit</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Qubits múltiples y Entanglement</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">11. Múltiples qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema5_phase-kickback.html">12. Explorando la puerta CNOT-Gate <a id="exploring-cnot"></a></a></li>

<li class="toctree-l1"><a class="reference internal" href="Tema6_more-circuit-identities.html">14. Otros circuitos</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema7_proving-universality.html">15. Universalidad</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema8_QFT.html">16. Transformada cuántica de Fourier</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Algoritmos cuánticos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="algoritmos/deutsch_Jozsa.html">18. Algoritmo Deutsch_Jozsa</a></li>
<li class="toctree-l1"><a class="reference internal" href="algoritmos/Algoritmo_Grover.html">19. Algoritmo de Grover</a></li>
<li class="toctree-l1"><a class="reference internal" href="algoritmos/qpe.html">20. quantum phase estimation(QPE)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Índice de términos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">21. Índice de términos</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Apéndice</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="otras/anexo1_Algebralineal.html">Resumen Algebra lineal</a></li>
<li class="toctree-l1"><a class="reference internal" href="anexo_simpy.html">Matemática simbólica</a></li>
<li class="toctree-l1"><a class="reference internal" href="paquetequtip.html">Paquete Qutib: Representación esfera Bloch</a></li>
<li class="toctree-l1"><a class="reference internal" href="videos_anexo.html">Vídeos</a></li>
<li class="toctree-l1"><a class="reference internal" href="otras/apendice.html">Apendice.</a></li>




</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/jupyters/Tema4_multiple-qubits-entangled-states.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Qubits Múltiples  y Entangled States</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#representando-el-estado-de-multi-qubit-a-id-represent-a">11.1. Representando el estado de Multi-Qubit <a id="represent"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-ejercicios-a-id-ex1-a">11.1.1. Quick Ejercicios: <a id="ex1"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#single-qubit-gates-on-multi-qubit-statevectors-a-id-single-qubit-gates-a">11.2. Single Qubit Gates on Multi-Qubit Statevectors <a id="single-qubit-gates"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-ejercicios-a-id-ex2-a">11.2.1. Quick Ejercicios: <a id="ex2"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-gates-a-id-multi-qubit-gates-a">11.3. Multi-Qubit Gates <a id="multi-qubit-gates"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cnot-gate-a-id-cnot-a">11.3.1. CNOT-Gate <a id="cnot"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entangled-states-a-id-entangled-a">11.3.2. Entangled States <a id="entangled"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizacion-de-entangled-states-a-id-visual-a">11.3.3. Visualización de Entangled States<a id="visual"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ejercicios-a-id-ex3-a">11.3.4. Ejercicios: <a id="ex3"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">11.4. Referencias</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="qubits-multiples-y-entangled-states">
<h1><span class="section-number">11. </span>Qubits Múltiples  y Entangled States<a class="headerlink" href="#qubits-multiples-y-entangled-states" title="Permalink to this heading">#</a></h1>
<p>Los qubits individuales son interesantes, pero individualmente no ofrecen ninguna ventaja computacional. En este apartado veremos cómo representar varios qubits y cómo pueden interactuar entre sí. Hemos visto cómo podemos representar el estado de un qubit utilizando un vector 2D, ahora veremos cómo podemos representar el estado de múltiples qubits.</p>
<section id="representando-el-estado-de-multi-qubit-a-id-represent-a">
<h2><span class="section-number">11.1. </span>Representando el estado de Multi-Qubit <a id="represent"></a><a class="headerlink" href="#representando-el-estado-de-multi-qubit-a-id-represent-a" title="Permalink to this heading">#</a></h2>
<p>Como ya hemos visto en el anterior apartado, el estado de un qubit tiene dos amplitudes representadas por numeros complejos. Si extendemos esta idea a dos qubits, podemos decir que tiene cuatros posibles estados.</p>
<p><code class="docutils literal notranslate"><span class="pre">00</span></code> <code class="docutils literal notranslate"><span class="pre">01</span></code> <code class="docutils literal notranslate"><span class="pre">10</span></code> <code class="docutils literal notranslate"><span class="pre">11</span></code></p>
<p>Y además para describir el estado de dos qubits se requieren cuatro amplitudes indicadas por cuatro números complejos. De acuerdo con esta idea la representación que utilizaremos será la siguiente:</p>
<div class="math notranslate nohighlight">
\[\begin{split} |a\rangle = a_{00}|00\rangle + a_{01}|01\rangle + a_{10}|10\rangle + a_{11}|11\rangle = \begin{bmatrix} a_{00} \\ a_{01} \\ a_{10} \\ a_{11} \end{bmatrix} \end{split}\]</div>
<p>Siendo <span class="math notranslate nohighlight">\(a_{i,j}\)</span> números complejos.</p>
<p>Las probabilidades se calculan de la misma manera que para un qubit</p>
<div class="math notranslate nohighlight">
\[ p(|00\rangle) = |\langle 00 | a \rangle |^2 = |a_{00}|^2\]</div>
<p>Y también se debe cumplir la condición de normalización:</p>
<div class="math notranslate nohighlight">
\[ |a_{00}|^2 + |a_{01}|^2 + |a_{10}|^2 + |a_{11}|^2 = 1\]</div>
<p>Cuando tenemos dos qubits separados, podemos describir su estado conjunto mediante el <em>producto de kronecker</em>:</p>
<div class="math notranslate nohighlight" id="index-0">
\[\begin{split} |a\rangle = \begin{bmatrix} a_0 \\ a_1 \end{bmatrix}, \quad |b\rangle = \begin{bmatrix} b_0 \\ b_1 \end{bmatrix} \end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split} 
|ba\rangle = |b\rangle \otimes |a\rangle = \begin{bmatrix} b_0 \times \begin{bmatrix} a_0 \\ a_1 \end{bmatrix} \\ b_1 \times \begin{bmatrix} a_0 \\ a_1 \end{bmatrix} \end{bmatrix} = \begin{bmatrix} b_0 a_0 \\ b_0 a_1 \\ b_1 a_0 \\ b_1 a_1 \end{bmatrix}
\end{split}\]</div>
<p>Y siguiendo las mismas reglas, podemos utilizar el <em>producto de kronecker</em> para describir el estado colectivo de cualquier número de qubits. A continuación se muestra un ejemplo con tres qubits:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
|cba\rangle = \begin{bmatrix} c_0 b_0 a_0 \\ c_0 b_0 a_1 \\ c_0 b_1 a_0 \\ c_0 b_1 a_1 \\
                              c_1 b_0 a_0 \\ c_1 b_0 a_1 \\ c_1 b_1 a_0 \\ c_1 b_1 a_1 \\
              \end{bmatrix}
\end{split}\]</div>
<p>Si tenemos <span class="math notranslate nohighlight">\(n\)</span> qubits, necesitaremos tener en cuenta un total de <span class="math notranslate nohighlight">\(2^n\)</span> amplitudes complejas. Como vemos, estos vectores crecen exponencialmente con el número de qubits. Esta es la razón por la que los ordenadores cuánticos con un gran número de qubits son tan difíciles de simular. Un portátil moderno puede simular fácilmente un estado cuántico general de unos 20 qubits, pero simular 100 qubits es demasiado difícil incluso para los mayores superordenadores.</p>
<p>A continuación mostramos un circuito con tres qubits, y una serie de pertas lógicas</p>
<div class="cell tag_thebelab-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">assemble</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span><span class="p">,</span> <span class="n">plot_bloch_multivector</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># Aplicamos un apuerta H a cada uno de qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
<span class="c1"># Mostramos el circuito</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;iqp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/c89d049e2d18c52951e7c3730d33854cf1c71de82894e6e96ac0d25767944882.png" src="../_images/c89d049e2d18c52951e7c3730d33854cf1c71de82894e6e96ac0d25767944882.png" />
</div>
</div>
<p>Cada qubit tiene como salida el estado <span class="math notranslate nohighlight">\(|+\rangle\)</span>, ya que <span class="math notranslate nohighlight">\(H|0\rangle\)</span> da como resultado el estado <span class="math notranslate nohighlight">\(|+\rangle\)</span>. Por lo tanto el vector de salida será:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
|{+++}\rangle = \frac{1}{\sqrt{8}}\begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \\
                              1 \\ 1 \\ 1 \\ 1 \\
              \end{bmatrix}
\end{split}\]</div>
<p>Veamos que esto es cierto utilizando código de qiskit.</p>
<div class="cell docutils container" id="index-1">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the result</span>
<span class="n">svsim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="c1">#final_state = svsim.run(qobj).result().get_statevector()</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">svsim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>

<span class="c1"># In Jupyter Notebooks we can display this nicely using Latex.</span>
<span class="c1"># If not using Jupyter Notebooks you may need to remove the </span>
<span class="c1"># array_to_latex function and use print(final_state) instead.</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">array_to_latex</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text</span><span class="si">{Statevector}</span><span class="s2"> = &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\Francisco\AppData\Local\Temp\ipykernel_2276\1334342041.py:2: DeprecationWarning: The &#39;qiskit.Aer&#39; entry point is deprecated and will be removed in Qiskit 1.0. You should use &#39;qiskit_aer.Aer&#39; directly instead.
  svsim = Aer.get_backend(&#39;aer_simulator&#39;)
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{Statevector} = 
\begin{bmatrix}
\frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Obteniendo el resultado esperado.</p>
<p>Podemos también obtener la representación matricial de las tres puertas de Hadamar que se han utilizado, es decir el resultado de la siguiente expresión:</p>
<div class="math notranslate nohighlight">
\[H\otimes H \otimes H \]</div>
<p>Siendo el producto anterior el denominado producto tensorial o producto de kronecker, cuyo significado ya se ha comentado anteriormente.</p>
<div class="cell docutils container" id="index-2">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c1"># Apply H-gate to each qubit:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>


<span class="n">qc</span><span class="o">.</span><span class="n">save_unitary</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="c1">#unitary = svsim.run(qobj).result().get_unitary()</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">svsim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">array_to_latex</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text{Circuit = }</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\text{Circuit = }\\\begin{split}\begin{bmatrix}
\frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; - \frac{\sqrt{2}}{4}  \\
 \end{bmatrix}
\end{split}\end{aligned}\end{align} \]</div>
</div>
</div>
<section id="quick-ejercicios-a-id-ex1-a">
<h3><span class="section-number">11.1.1. </span>Quick Ejercicios: <a id="ex1"></a><a class="headerlink" href="#quick-ejercicios-a-id-ex1-a" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Escribir el producto de kronecker de los siguintes qubits:<br />
a)	<span class="math notranslate nohighlight">\(|0\rangle|1\rangle\)</span><br />
b)	<span class="math notranslate nohighlight">\(|0\rangle|+\rangle\)</span><br />
c)	<span class="math notranslate nohighlight">\(|+\rangle|1\rangle\)</span><br />
d)	<span class="math notranslate nohighlight">\(|-\rangle|+\rangle\)</span></p></li>
<li><p>Escribir el estado de:
<span class="math notranslate nohighlight">\(|\psi\rangle = \tfrac{1}{\sqrt{2}}|00\rangle + \tfrac{i}{\sqrt{2}}|01\rangle \)</span>
como dos qubits separados.</p></li>
</ol>
</section>
</section>
<section id="single-qubit-gates-on-multi-qubit-statevectors-a-id-single-qubit-gates-a">
<h2><span class="section-number">11.2. </span>Single Qubit Gates on Multi-Qubit Statevectors <a id="single-qubit-gates"></a><a class="headerlink" href="#single-qubit-gates-on-multi-qubit-statevectors-a-id-single-qubit-gates-a" title="Permalink to this heading">#</a></h2>
<p>Ya hemos visto que una puerta X,que actúa sobre un sólo qubit ,queda representada por una matriz 2x2 de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}
\end{split}\]</div>
<p>Y que por consiguiente actúa sobre un estado <span class="math notranslate nohighlight">\(|0\rangle\)</span> de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X|0\rangle = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}\begin{bmatrix} 1 \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ 1\end{bmatrix}
\end{split}\]</div>
<p>Pero puede que no esté claro cómo actuaría una puerta X sobre un qubit en un vector multiqubit. Afortunadamente, la regla es bastante sencilla; igual que utilizamos el producto kronecker para calcular vectores de estado multiqubit, utilizamos el producto tensor para calcular matrices que actúan sobre estos vectores de estado. Por ejemplo, en el circuito de abajo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>D:\programas\Anaconda\Lib\site-packages\qiskit\visualization\circuit\matplotlib.py:266: FutureWarning: The default matplotlib drawer scheme will be changed to &quot;iqp&quot; in a following release. To silence this warning, specify the current default explicitly as style=&quot;clifford&quot;, or the new default as style=&quot;iqp&quot;.
  self._style, def_font_ratio = load_style(self._style)
</pre></div>
</div>
<img alt="../_images/a96306a5de97a5b57fdf558e81a794077f130124543b7b3b4450aad795ab03a7.png" src="../_images/a96306a5de97a5b57fdf558e81a794077f130124543b7b3b4450aad795ab03a7.png" />
</div>
</div>
<p>podemos representar las operaciones simultáneas (H &amp; X) utilizando su producto de kronecker, de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[
X|q_1\rangle \otimes H|q_0\rangle = (X\otimes H)|q_1 q_0\rangle
\]</div>
<p>Estas operaciones se harían de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X\otimes H = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \otimes \tfrac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
= \frac{1}{\sqrt{2}}
\begin{bmatrix} 0 \times \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}
              &amp; 1 \times \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}
                \\ 
                1 \times \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}
              &amp; 0 \times \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}
\end{bmatrix} 
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
= \frac{1}{\sqrt{2}}
\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 1 \\
                0 &amp; 0 &amp; 1 &amp; -1 \\
                1 &amp; 1 &amp; 0 &amp; 0 \\
                1 &amp; -1 &amp; 0 &amp; 0 \\
\end{bmatrix}
\end{split}\]</div>
<p>Matriz que luego podemos aplicar a nuestro vector de estado (<em>statevector</em>) 4D <span class="math notranslate nohighlight">\(|q_1 q_0\rangle\)</span>. Utilizando tanto numéro quizá no veamos con claridad qué resultado se obtiene,por ese motivo a menudo se ve la notación más clara de la siguiente manera:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X\otimes H = 
\begin{bmatrix} 0 &amp; H \\
               H &amp; 0\\
\end{bmatrix}
\end{split}\]</div>
<p>En lugar de calcular esto a mano,como se ha hecho anteriormente, podemos utilizar el <code class="docutils literal notranslate"><span class="pre">aer_simulator</span></code> de Qiskit para que lo calcule por nosotros. El simulador Aer multiplica todas las puertas de nuestro circuito para compilar una única matriz unitaria que ejecuta todo el circuito cuántico:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">usim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_unitary</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="c1">#unitary = usim.run(qobj).result().get_unitary()</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">usim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>y obteniendo como resultado el siguiente:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In Jupyter Notebooks we can display this nicely using Latex.</span>
<span class="c1"># If not using Jupyter Notebooks you may need to remove the </span>
<span class="c1"># array_to_latex function and use print(unitary) instead.</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">array_to_latex</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text{Circuit = }</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\text{Circuit = }\\\begin{split}\begin{bmatrix}
0 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; \frac{\sqrt{2}}{2}  \\
 0 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; - \frac{\sqrt{2}}{2}  \\
 \frac{\sqrt{2}}{2} &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0  \\
 \frac{\sqrt{2}}{2} &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; 0  \\
 \end{bmatrix}
\end{split}\end{aligned}\end{align} \]</div>
</div>
</div>
<p>Si queremos aplicar una puerta sólo a un qubit a la vez (como en el circuito que mostramos a continuación de este párrafo), lo describimos usando el producto de kronecker con la matriz identidad, y así por ejemplo:</p>
<div class="math notranslate nohighlight">
\[ X \otimes I \]</div>
<p>Esta expresión, utilizando qiskit sería de la siguiente manera:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/a17104ff52c3d44d06420c047acf4e6674d4a46e12ed62e69c129affe90eac56.png" src="../_images/a17104ff52c3d44d06420c047acf4e6674d4a46e12ed62e69c129affe90eac56.png" />
</div>
</div>
<p>Y la matriz unitaria que obtenemos sería la siguiente:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simulate the unitary</span>
<span class="n">usim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_unitary</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">usim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>
<span class="c1"># Display the results:</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text{Circuit = } &quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{Circuit = } 
\begin{bmatrix}
0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Podemos ver que Qiskit ha realizado el producto kronecker:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X \otimes I =
\begin{bmatrix} 0 &amp; I \\
               I &amp; 0\\
\end{bmatrix} = 
\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 1 \\
                1 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 0 &amp; 0 \\
\end{bmatrix}
\end{split}\]</div>
<section id="quick-ejercicios-a-id-ex2-a">
<h3><span class="section-number">11.2.1. </span>Quick Ejercicios: <a id="ex2"></a><a class="headerlink" href="#quick-ejercicios-a-id-ex2-a" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Calcular la matriz unitaria (<span class="math notranslate nohighlight">\(U\)</span>) obtenida mediante la siguiente secuencia de operaciones de puertas de qubits: <span class="math notranslate nohighlight">\(U = XZH\)</span>. Utilizar el aer_simulator de qiskit para comprobar el resultado obtenido de forma manual.</p></li>
<li><p>Prueba a cambiar las puertas del circuito anterior. Calcula su producto de Kronecker y comprueba tu respuesta con el simulador Aer.</p></li>
</ol>
<p><strong>Nota:</strong> Diferentes libros, softwares y sitios web ordenan los qubits de forma diferente a como se ha expuesto aquí y en el sentido con el que trabaja qiskit. Esto significaría que el producto kronecker de un mismo circuito puede parecer muy diferente. Tenlo en cuenta cuando consultes otras fuentes.</p>
</section>
</section>
<section id="multi-qubit-gates-a-id-multi-qubit-gates-a">
<h2><span class="section-number">11.3. </span>Multi-Qubit Gates <a id="multi-qubit-gates"></a><a class="headerlink" href="#multi-qubit-gates-a-id-multi-qubit-gates-a" title="Permalink to this heading">#</a></h2>
<p>Ahora que sabemos cómo representar el estado de múltiples qubits, estamos preparados para aprender cómo interactúan los qubits entre sí. Una puerta importante de dos qubits es la puerta CNOT, que a continuación se pasa a explicar.</p>
<section id="cnot-gate-a-id-cnot-a">
<span id="index-3"></span><h3><span class="section-number">11.3.1. </span>CNOT-Gate <a id="cnot"></a><a class="headerlink" href="#cnot-gate-a-id-cnot-a" title="Permalink to this heading">#</a></h3>
<p>Esta puerta es <em>una puerta condicional</em> que ejecuta una puerta-X en el segundo qubit (objetivo o target), si el estado del primer qubit (control) es <span class="math notranslate nohighlight">\(|1\rangle\)</span>. La puerta se dibuja en un circuito como el que se muestra a continuación, con <code class="docutils literal notranslate"><span class="pre">q0</span></code> como control y <code class="docutils literal notranslate"><span class="pre">q1</span></code> como objetivo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Apply CNOT</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># See the circuit:</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/c40bb1123fbaa3d4ff2ec3969d8fb0473c72ba7df6f369c3849dc02fe476c0ab.png" src="../_images/c40bb1123fbaa3d4ff2ec3969d8fb0473c72ba7df6f369c3849dc02fe476c0ab.png" />
</div>
</div>
<p>Cuando nuestros qubits no están en superposición de <span class="math notranslate nohighlight">\(|0\rangle\)</span> o <span class="math notranslate nohighlight">\(|1\rangle\)</span> (comportándose como bits clásicos), esta puerta es muy sencilla e intuitiva de entender. Podemos utilizar la tabla de verdad clásica siguiente:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Input (t,c)</p></th>
<th class="head text-center"><p>Output (t,c)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>00</p></td>
<td class="text-center"><p>00</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>01</p></td>
<td class="text-center"><p>11</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>10</p></td>
<td class="text-center"><p>10</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>11</p></td>
<td class="text-center"><p>01</p></td>
</tr>
</tbody>
</table>
<p>Y actuando sobre nuestro vector estado 4D, tiene una de las dos matrices siguientes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\text{CNOT} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
                              0 &amp; 0 &amp; 0 &amp; 1 \\
                              0 &amp; 0 &amp; 1 &amp; 0 \\
                              0 &amp; 1 &amp; 0 &amp; 0 \\
              \end{bmatrix}, \quad
\text{CNOT} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\
                              0 &amp; 1 &amp; 0 &amp; 0 \\
                              0 &amp; 0 &amp; 0 &amp; 1 \\
                              0 &amp; 0 &amp; 1 &amp; 0 \\
              \end{bmatrix}
\end{split}\]</div>
<p>dependiendo de qué qubit es el control y cuál es el objetivo. Diferentes libros, simuladores y documentos ordenan los qubits de forma diferente. En nuestro caso, la matriz de la izquierda corresponde a la CNOT del circuito anteriormente dibujado. Esta matriz intercambia las amplitudes de <span class="math notranslate nohighlight">\(|01\rangle\)</span> y <span class="math notranslate nohighlight">\(|11\rangle\)</span> en nuestro vector de estado:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
|a\rangle = \begin{bmatrix} a_{00} \\ a_{01} \\ a_{10} \\ a_{11} \end{bmatrix}, \quad \text{CNOT}|a\rangle = \begin{bmatrix} a_{00} \\ a_{11} \\ a_{10} \\ a_{01} \end{bmatrix} \begin{matrix} \\ \leftarrow \\ \\ \leftarrow \end{matrix}
\end{split}\]</div>
<p>Hemos visto cómo actúa sobre estados clásicos, pero veamos ahora cómo actúa sobre un qubit en superposición. Pondremos un qubit en el estado <span class="math notranslate nohighlight">\(|+\rangle\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Apply H-gate to the first:</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/638f268da2bcc507a97c0723c5959a3682acf32c5451ae2446f70d2db087a75a.png" src="../_images/638f268da2bcc507a97c0723c5959a3682acf32c5451ae2446f70d2db087a75a.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see the result:</span>
<span class="n">svsim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;aer_simulator&#39;</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">svsim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="c1"># Print the statevector neatly:</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text{Statevector = }&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{Statevector = }
\begin{bmatrix}
\frac{\sqrt{2}}{2} &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Como es de esperar, esto genera el estado <span class="math notranslate nohighlight">\(|0\rangle \otimes |{+}\rangle = |0{+}\rangle\)</span> (recordar que <span class="math notranslate nohighlight">\(H|0\rangle\)</span> genera el estado <span class="math notranslate nohighlight">\(|+\rangle\)</span>):</p>
<div class="math notranslate nohighlight">
\[
|0{+}\rangle = \tfrac{1}{\sqrt{2}}(|00\rangle + |01\rangle)
\]</div>
<p>Y veamos qué ocurre cuando aplicamos la puerta CNOT, con qiskit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Apply H-gate to the first:</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Apply a CNOT:</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;mpl&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/f0256c0212836ae05a2fe9b23c5f22aaa1c60f90044f071b93b2431c35b83763.png" src="../_images/f0256c0212836ae05a2fe9b23c5f22aaa1c60f90044f071b93b2431c35b83763.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s get the result:</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span>
<span class="c1">#qobj = assemble(qc)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">svsim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="c1"># Print the statevector neatly:</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="n">array_to_latex</span><span class="p">(</span><span class="n">final_state</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">text{Statevector = }&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{Statevector = }
\begin{bmatrix}
\frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; \frac{\sqrt{2}}{2}  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Es decir obtenemos el siguiente estado:</p>
<div class="math notranslate nohighlight">
\[
\text{CNOT}|0{+}\rangle = \tfrac{1}{\sqrt{2}}(|00\rangle + |11\rangle)
\]</div>
<p id="index-4">Este estado es muy interesante para nosotros, porque está <em>entangled.</em> Esto nos lleva claramente a la siguiente sección.</p>
</section>
<section id="entangled-states-a-id-entangled-a">
<h3><span class="section-number">11.3.2. </span>Entangled States <a id="entangled"></a><a class="headerlink" href="#entangled-states-a-id-entangled-a" title="Permalink to this heading">#</a></h3>
<p id="index-5">Vimos en la sección anterior que podíamos crear el estado siguiente:</p>
<div class="math notranslate nohighlight">
\[
\tfrac{1}{\sqrt{2}}(|00\rangle + |11\rangle)
\]</div>
<p>Este estado es conocido como <strong><em>Bell</em> state</strong>. Podemos ver que este estado tiene un 50% de probabilidad de ser medido en el estado <span class="math notranslate nohighlight">\(|00\rangle\)</span>, y un 50% de probabilidad de ser medido en el estado <span class="math notranslate nohighlight">\(|11\rangle\)</span>. Lo más interesante es que tiene un <strong>0%</strong> de probabilidad de ser medido en los estados <span class="math notranslate nohighlight">\(|01\rangle\)</span> o <span class="math notranslate nohighlight">\(|10\rangle\)</span>. Podemos ver esto de forma gráfica en Qiskit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_distribution</span>

<span class="c1"># con plot_histogram da un warning de que está deprecated</span>
<span class="n">plot_distribution</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/33defbdbb5065ea68c6f9fcbc8f16666ca5cb60ccb218cb84823e2460276b19d.png" src="../_images/33defbdbb5065ea68c6f9fcbc8f16666ca5cb60ccb218cb84823e2460276b19d.png" />
</div>
</div>
<p>Este estado combinado <em>no puede escribirse como dos estados qubit separados</em>, lo que tiene interesantes implicaciones. Aunque nuestros qubits están en superposición, medir uno nos dirá el estado del otro y colapsará su superposición. Por ejemplo, si medimos el qubit superior y obtenemos el estado <span class="math notranslate nohighlight">\(|1\rangle\)</span>, el estado colectivo de nuestros qubits cambia así:</p>
<div class="math notranslate nohighlight">
\[
\tfrac{1}{\sqrt{2}}(|00\rangle + |11\rangle) \quad \xrightarrow[]{\text{measure}} \quad |11\rangle
\]</div>
<p>Aunque separemos estos qubits a años luz de distancia, la medición de uno de ellos colapsa la superposición y parece tener un efecto inmediato sobre el otro. Esta es la <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_nonlocality">‘espeluznante acción a distancia’</a> que perturbó a tantos físicos a principios del siglo XX.</p>
<p>Es importante señalar que el resultado de la medición es aleatorio, y que las estadísticas de medición de un qubit <strong>no</strong> se ven afectadas por ninguna operación en el otro qubit. Debido a esto, no hay <strong>ningún modo</strong> de utilizar estados cuánticos compartidos para comunicarse. Esto se conoce como el teorema de la no-comunicación.</p>
</section>
<section id="visualizacion-de-entangled-states-a-id-visual-a">
<h3><span class="section-number">11.3.3. </span>Visualización de Entangled States<a id="visual"></a><a class="headerlink" href="#visualizacion-de-entangled-states-a-id-visual-a" title="Permalink to this heading">#</a></h3>
<p>Hemos visto que este estado no se puede escribir como dos estados qubit separados, esto también significa que perdemos información cuando intentamos graficar nuestro estado en esferas de Bloch separadas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">final_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/7d502a025287b9b787f770cdfb3b939cf231d20868ea4e5961fabe81c630a347.png" src="../_images/7d502a025287b9b787f770cdfb3b939cf231d20868ea4e5961fabe81c630a347.png" />
</div>
</div>
<p>Teniendo en cuenta cómo hemos definido la esfera de Bloch en los capítulos anteriores, puede que no esté claro cómo Qiskit incluso calcula los vectores de Bloch con qubits enredados como éste. En el caso de un solo qubit, la posición del vector de Bloch a lo largo de un eje se corresponde perfectamente con el valor de expectativa de la medición en esa base. Si tomamos esto como <em>la</em> regla de trazado de los vectores de Bloch, llegamos a la conclusión anterior. Esto nos muestra que no hay <em>ninguna</em> base de medida de un solo qubit para la que esté garantizada una medida específica. Esto contrasta con nuestros estados de qubit único, en los que siempre podríamos elegir una base de qubit único. Si observamos los qubits individuales de este modo, pasamos por alto el importante efecto de la correlación entre los qubits. No podemos distinguir entre diferentes estados entrelazados. Por ejemplo, los dos estados</p>
<div class="math notranslate nohighlight">
\[\tfrac{1}{\sqrt{2}}(|01\rangle + |10\rangle) \quad \text{and} \quad \tfrac{1}{\sqrt{2}}(|00\rangle + |11\rangle)\]</div>
<p>tendrán ambas el mismo aspecto en estas esferas de Bloch separadas, a pesar de ser estados muy diferentes con resultados de medición distintos.</p>
<p>¿De qué otra forma podríamos visualizar este vector de estado? Este vector de estado es simplemente una colección de cuatro amplitudes (números complejos), y hay infinitas formas de representarlo en una imagen. Una de ellas es la “Q-sphere”, en la que cada amplitud está representada por una mancha en la superficie de una esfera. El tamaño de la mancha es proporcional a la magnitud de la amplitud, y el color es proporcional a la fase de la amplitud. En el ejemplo que estamos contemplando, las amplitudes para <span class="math notranslate nohighlight">\(|00\rangle\)</span> y <span class="math notranslate nohighlight">\(|11\rangle\)</span> son iguales, y todas las demás amplitudes son 0:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_state_qsphere</span>
<span class="n">plot_state_qsphere</span><span class="p">(</span><span class="n">final_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2dda7fedbfe93965b82e1b070fbd7559738cede1afc44ee8ac2b7ae8c1a9c82d.png" src="../_images/2dda7fedbfe93965b82e1b070fbd7559738cede1afc44ee8ac2b7ae8c1a9c82d.png" />
</div>
</div>
<p>Aquí podemos ver claramente la correlación entre los qubits. La forma de la esfera Q no tiene ningún significado, es simplemente una forma agradable de organizar nuestros blobs; el número de <code class="docutils literal notranslate"><span class="pre">0</span></code>s en el estado es proporcional a la posición de los estados en el eje Z, así que aquí podemos ver que la amplitud de <span class="math notranslate nohighlight">\(|00\rangle\)</span> está en el polo superior de la esfera, y la amplitud de <span class="math notranslate nohighlight">\(|11\rangle\)</span> está en el polo inferior de la esfera.</p>
</section>
<section id="ejercicios-a-id-ex3-a">
<h3><span class="section-number">11.3.4. </span>Ejercicios: <a id="ex3"></a><a class="headerlink" href="#ejercicios-a-id-ex3-a" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Crear un circuito cuántico que produzca el estado de Bell: <span class="math notranslate nohighlight">\(\tfrac{1}{\sqrt{2}}(|01\rangle + |10\rangle)\)</span>.
Utiliza el simulador de vectores de estado para verificar tu resultado.</p></li>
<li><p>El circuito que has creado en la pregunta 1 transforma el estado <span class="math notranslate nohighlight">\(|00\rangle\)</span> a <span class="math notranslate nohighlight">\(\tfrac{1}{\sqrt{2}}(|01\rangle + |10\rangle)\)</span>, calcula la matriz unitaria de este circuito utilizando el simulador de Qiskit. Comprueba que esta matriz unitariz realiza la transformación correcta.</p></li>
<li><p>Piensa en otras formas de representar visualmente un vector de estado. ¿Puedes diseñar una visualización interesante en la que puedas leer la magnitud y la fase de cada amplitud?</p></li>
</ol>
</section>
</section>
<section id="referencias">
<h2><span class="section-number">11.4. </span>Referencias<a class="headerlink" href="#referencias" title="Permalink to this heading">#</a></h2>
<p>[1] Asher Peres, Daniel R. Terno, <em>Quantum Information and Relativity Theory,</em> 2004, <a class="reference external" href="https://arxiv.org/abs/quant-ph/0212023">https://arxiv.org/abs/quant-ph/0212023</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="o">%</span><span class="k">qiskit_version_table</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\Francisco\AppData\Local\Temp\ipykernel_2276\3369625891.py:1: DeprecationWarning: qiskit.tools.jupyter is deprecated and will be removed in Qiskit 1.0.0
  import qiskit.tools.jupyter
</pre></div>
</div>
<div class="output text_html"><h3>Version Information</h3><table><tr><th>Software</th><th>Version</th></tr><tr><td><code>qiskit</code></td><td>0.46.0</td></tr><tr><td><code>qiskit_aer</code></td><td>0.13.2</td></tr><tr><th colspan='2'>System information</th></tr><tr><td>Python version</td><td>3.11.4</td></tr><tr><td>Python compiler</td><td>MSC v.1916 64 bit (AMD64)</td></tr><tr><td>Python build</td><td>main, Jul  5 2023 13:38:37</td></tr><tr><td>OS</td><td>Windows</td></tr><tr><td>CPUs</td><td>4</td></tr><tr><td>Memory (Gb)</td><td>11.799663543701172</td></tr><tr><td colspan='2'>Sat Feb 03 21:20:15 2024 Hora estándar romance</td></tr></table></div></div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./jupyters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="Tema3_single-qubit-gates.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Puertas cuánticas simples</p>
      </div>
    </a>
    <a class="right-next"
       href="Tema5_phase-kickback.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">12. </span>Explorando la puerta CNOT-Gate <a id="exploring-cnot"></a></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#representando-el-estado-de-multi-qubit-a-id-represent-a">11.1. Representando el estado de Multi-Qubit <a id="represent"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-ejercicios-a-id-ex1-a">11.1.1. Quick Ejercicios: <a id="ex1"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#single-qubit-gates-on-multi-qubit-statevectors-a-id-single-qubit-gates-a">11.2. Single Qubit Gates on Multi-Qubit Statevectors <a id="single-qubit-gates"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-ejercicios-a-id-ex2-a">11.2.1. Quick Ejercicios: <a id="ex2"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-gates-a-id-multi-qubit-gates-a">11.3. Multi-Qubit Gates <a id="multi-qubit-gates"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cnot-gate-a-id-cnot-a">11.3.1. CNOT-Gate <a id="cnot"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#entangled-states-a-id-entangled-a">11.3.2. Entangled States <a id="entangled"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#visualizacion-de-entangled-states-a-id-visual-a">11.3.3. Visualización de Entangled States<a id="visual"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ejercicios-a-id-ex3-a">11.3.4. Ejercicios: <a id="ex3"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#referencias">11.4. Referencias</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Francisco Rodríguez
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>