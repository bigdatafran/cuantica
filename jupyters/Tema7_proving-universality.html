

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>15. Proving Universality &#8212; Programación Cuántica</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'jupyters/Tema7_proving-universality';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16. Transformada cuántica de Fourier" href="Tema8_QFT.html" />
    <link rel="prev" title="14. Más ciruitos cuánticos" href="Tema6_more-circuit-identities.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../introduccion.html">
  
  
  
  
  
    <p class="title logo__title">Programación Cuántica</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../introduccion.html">
                    Introducción
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Base teórica de la programación cuántica</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_I.html">1. Los qubits en la programación cuántica</a></li>
<li class="toctree-l1"><a class="reference internal" href="numeros_complejos.html">2. Introducción a los números complejos</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_II.html">3. Otros aspectos de los qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParteTeorica_III_puertasCuanticas.html">4. Puertas cuánticas</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parte_teorica_IV_algebra.html">5. Álgebra lineal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Parte_teorica_V_qubitMultiple.html">6. Múltiples qubits</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Estados quanticos y qubits</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tema0_Introducci%C3%B3n.html">7. Introducción a programación cuántica</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema1_atoms-computation.html">8. Los qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema2_representing-qubit-states.html">9. Representación de los estados del qubit</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema3_single-qubit-gates.html">10. Puertas cuánticas para un qubit</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Qubits múltiples y Entanglement</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Tema4_multiple-qubits-entangled-states.html">11. Múltiples qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema5_phase-kickback.html">12. Explorando la puerta CNOT-Gate <a id="exploring-cnot"></a></a></li>

<li class="toctree-l1"><a class="reference internal" href="Tema6_more-circuit-identities.html">14. Otros circuitos</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">15. Universalidad</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tema8_QFT.html">16. Transformada cuántica de Fourier</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Algoritmos cuánticos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="algoritmos/deutsch_Jozsa.html">18. Algoritmo Deutsch_Jozsa</a></li>
<li class="toctree-l1"><a class="reference internal" href="algoritmos/Algoritmo_Grover.html">19. Algoritmo de Grover</a></li>
<li class="toctree-l1"><a class="reference internal" href="algoritmos/qpe.html">20. quantum phase estimation(QPE)</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Índice de términos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">21. Índice de términos</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Apéndice</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="otras/anexo1_Algebralineal.html">Resumen Algebra lineal</a></li>
<li class="toctree-l1"><a class="reference internal" href="anexo_simpy.html">Matemática simbólica</a></li>
<li class="toctree-l1"><a class="reference internal" href="paquetequtip.html">Paquete Qutib: Representación esfera Bloch</a></li>
<li class="toctree-l1"><a class="reference internal" href="videos_anexo.html">Vídeos</a></li>
<li class="toctree-l1"><a class="reference internal" href="otras/apendice.html">Apendice.</a></li>




</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/jupyters/Tema7_proving-universality.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Proving Universality <a id='intro'></a></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operaciones-con-matrices-a-id-fun-a">15.1. Operaciones con matrices <a id="fun"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-como-outer-products-a-id-outer-a">15.1.1. Matrices como outer products <a id="outer"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-unitarias-y-hermitianas-a-id-u-and-h-a">15.1.2. Matrices Unitarias y Hermitianas. <a id="u-and-h"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pauli-decomposition-a-id-pauli-a">15.1.3. 2.3 Pauli decomposition <a id="pauli"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#defining-universality-a-id-defining-a">15.2. 3. Defining Universality <a id="defining"></a></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-gate-sets-a-id-basic-a">15.3. 4. Basic Gate Sets <a id="basic"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clifford-gates-a-id-big-red-a">15.3.1. 4.1 Clifford Gates <a id="big-red"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#non-clifford-gates-a-id-non-clifford-a">15.3.2. 4.2 Non-Clifford Gates <a id="non-clifford"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#expanding-the-gate-set-a-id-expanding-a">15.3.3. 4.3 Expanding the Gate Set <a id="expanding"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#proving-universality-a-id-proving-a">15.4. 5. Proving Universality <a id="proving"></a></a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="proving-universality-a-id-intro-a">
<h1><span class="section-number">15. </span>Proving Universality <a id='intro'></a><a class="headerlink" href="#proving-universality-a-id-intro-a" title="Permalink to this heading">#</a></h1>
<p>¿Qué puede hacer un ordenador? ¿Cuáles son los límites de lo que se considera computable, en general? Alan Turing se planteó estas preguntas antes de que supiéramos qué era un ordenador o cómo construirlo.</p>
<p>Para plantear esta pregunta a nuestros ordenadores clásicos, y en concreto a nuestros ordenadores digitales estándar, tenemos que despojarnos de todas las pantallas, altavoces y dispositivos de entrada extravagantes. Lo que nos queda es simplemente una máquina que convierte cadenas de bits de entrada en cadenas de bits de salida. Si un dispositivo puede realizar cualquier conversión, tomando cualquier conjunto arbitrario de entradas y convirtiéndolas en un conjunto arbitrario de salidas correspondientes, lo llamamos <em>universal</em>.</p>
<p>Del mismo modo, los ordenadores cuánticos toman estados de entrada y los convierten en estados de salida. Por tanto, podremos definir la universalidad de forma similar. Para ser más precisos, y poder demostrar cuándo se puede y cuándo no se puede alcanzar la universalidad, es útil utilizar la representación matricial de nuestras puertas cuánticas. Pero antes tendremos que repasar algunas técnicas.</p>
<section id="operaciones-con-matrices-a-id-fun-a">
<h2><span class="section-number">15.1. </span>Operaciones con matrices <a id='fun'></a><a class="headerlink" href="#operaciones-con-matrices-a-id-fun-a" title="Permalink to this heading">#</a></h2>
<section id="matrices-como-outer-products-a-id-outer-a">
<h3><span class="section-number">15.1.1. </span>Matrices como outer products <a id='outer'></a><a class="headerlink" href="#matrices-como-outer-products-a-id-outer-a" title="Permalink to this heading">#</a></h3>
<p>En secciones anteriores hemos calculado muchos productos internos, como <span class="math notranslate nohighlight">\(\langle0|0\rangle =1\)</span>. Estos combinan un bra y un ket para darnos un solo número. También podemos combinarlos de forma que nos den una matriz, simplemente poniéndolos en el orden inverso. Esto se llama un producto externo, y funciona por multiplicación matricial estándar. Por ejemplo</p>
<div class="math notranslate nohighlight">
\[\begin{split}
|0\rangle\langle0|= \begin{pmatrix} 1 \\ 0 \end{pmatrix} \begin{pmatrix} 1 &amp; 0 \end{pmatrix} = \begin{pmatrix} 1&amp;0 \\ 0&amp;0 \end{pmatrix},\\
|0\rangle\langle1| = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \begin{pmatrix} 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 0&amp;1 \\ 0&amp;0 \end{pmatrix},\\
|1\rangle\langle0| = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \begin{pmatrix} 1 &amp; 0 \end{pmatrix} = \begin{pmatrix} 0&amp;0 \\ 1&amp;0 \end{pmatrix},\\
|1\rangle\langle1| = \begin{pmatrix} 0 \\ 1 \end{pmatrix} \begin{pmatrix} 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 0&amp;0 \\ 0&amp;1 \end{pmatrix}.\\
\end{split}\]</div>
<p>Esto también significa que podemos escribir cualquier matriz puramente en términos de productos externos. En los ejemplos anteriores, construimos las cuatro matrices que cubren cada uno de los elementos individuales de una matriz de un solo qubit, por lo que podemos escribir cualquier otra matriz de un solo qubit en términos de ellas.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M= \begin{pmatrix} m_{0,0}&amp; m_{0,1} \\ m_{1,0}&amp;m_{1,1} \end{pmatrix} = m_{0,0} |0\rangle\langle0|+ m_{0,1} |0\rangle\langle1|+ m_{1,0} |1\rangle\langle0|+ m_{1,1} |1\rangle\langle1|
\end{split}\]</div>
<p>Esta propiedad también se extiende a las matrices para cualquier número de qubits, <span class="math notranslate nohighlight">\(n\)</span>. Simplemente utilizamos los productos externos de las correspondientes cadenas de <span class="math notranslate nohighlight">\(n\)</span> bits.</p>
</section>
<section id="matrices-unitarias-y-hermitianas-a-id-u-and-h-a">
<h3><span class="section-number">15.1.2. </span>Matrices Unitarias y Hermitianas. <a id='u-and-h'></a><a class="headerlink" href="#matrices-unitarias-y-hermitianas-a-id-u-and-h-a" title="Permalink to this heading">#</a></h3>
<p id="index-0">El conjugado hermitiano <span class="math notranslate nohighlight">\(M^\dagger\)</span> de una matriz <span class="math notranslate nohighlight">\(M\)</span> es la combinación de la transposición \ (sustituir el elemento inferior izquierdo por el superior derecho, y así sucesivamente) y el conjugado complejo de cada elemento. Dos familias de matrices muy importantes para la computación cuántica se definen por su relación con el conjugado hermitiano. Una es la familia de matrices unitarias, para las que</p>
<div class="math notranslate nohighlight">
\[
U U^\dagger = U^\dagger U = I.
\]</div>
<p>Esto significa que el conjugado hermitiano de un unitario es su inverso: otro unitario <span class="math notranslate nohighlight">\(U^\dagger\)</span> con el poder de deshacer los efectos de <span class="math notranslate nohighlight">\(U\)</span>. <strong>Todas las puertas de la computación cuántica, a excepción de las operaciones de medida y reinicio, pueden representarse mediante matrices unitarias</strong>.</p>
<p>Otra consecuencia de la unitariedad es que preserva el producto interior entre dos estados arbitrarios. En concreto, tomemos dos estados <span class="math notranslate nohighlight">\(\left| \psi_0 \right\rangle\)</span> y <span class="math notranslate nohighlight">\(\left| \psi_1 \right\rangle\)</span>. El producto interior de estos es <span class="math notranslate nohighlight">\(\left\langle \psi_0 | \psi_1 \right\rangle\)</span>. Si aplicamos el mismo unitario <span class="math notranslate nohighlight">\(U\)</span> a ambos, el producto interior de los estados resultantes es exactamente el mismo,</p>
<div class="math notranslate nohighlight">
\[
\left( \left\langle \psi_0 \right| U^\dagger \right) \left( U \left| \psi_1 \right\rangle \right) = \left\langle \psi_0 \right|U^\dagger U\left| \psi_1 \right\rangle = \left\langle \psi_0 | \psi_1 \right\rangle.
\]</div>
<p>Esta propiedad nos proporciona una forma útil de pensar acerca de estas puertas. Significa que para cualquier conjunto de estados <span class="math notranslate nohighlight">\(\{ \left| \psi_j \right\rangle \}\)</span> que proporcionan una base ortonormal para nuestro sistema, el conjunto de estados <span class="math notranslate nohighlight">\(\{ \left| \phi_j \right\rangle = U \left| \psi_j \right\rangle \}\)</span> también será una base ortonormal. El unitario puede considerarse entonces como una rotación entre estas bases, y puede escribirse en consecuencia como</p>
<div class="math notranslate nohighlight">
\[
U = \sum_j \left| \phi_j \right\rangle \left\langle \psi_j \right|.
\]</div>
<p>Se trata esencialmente de la versión cuántica de las “tablas de verdad” que describen la acción de las puertas booleanas clásicas.</p>
<p>La otra familia importante de matrices son las matrices hermitianas. Son aquellas a las que no afecta el conjugado hermitiano</p>
<div class="math notranslate nohighlight">
\[
H = H^\dagger.
\]</div>
<p>Las matrices <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span>, <span class="math notranslate nohighlight">\(Z\)</span> y <span class="math notranslate nohighlight">\(H\)</span> son ejemplos de matrices hermitianas que ya has visto \ (casualmente, también son todas unitarias ya que son sus propias inversas).</p>
<p>Todas las matrices unitarias y las matrices hermitianas tienen la propiedad de <strong>ser diagonalizables</strong>. Esto significa que pueden escribirse de la forma</p>
<div class="math notranslate nohighlight">
\[
M = \sum_j \lambda_j |h_j\rangle\langle h_j|,
\]</div>
<p>donde <span class="math notranslate nohighlight">\(\lambda_j\)</span> son los valores propios de la matriz y <span class="math notranslate nohighlight">\(|h_j\rangle\)</span> son los estados propios correspondientes.</p>
<p>Para los unitarios, aplicar la condición <span class="math notranslate nohighlight">\(U U^\dagger=I\)</span> en esta forma diagonal implica que <span class="math notranslate nohighlight">\(\lambda_j \lambda_j^* = 1\)</span>. Por tanto, los valores propios son siempre <strong>números complejos de magnitud 1</strong>, por lo que pueden expresarse <span class="math notranslate nohighlight">\(e^{ih_j}\)</span> para algún valor real <span class="math notranslate nohighlight">\(h_j\)</span>. Para matrices hermitianas la condición <span class="math notranslate nohighlight">\(H = H^\dagger\)</span> implica <span class="math notranslate nohighlight">\(\lambda_j = \lambda_j^*\)</span>, y por tanto que <strong>todos los valores propios son reales</strong>.</p>
<p>Por tanto, estos dos tipos de matrices sólo se diferencian en que una debe tener números reales para los valores propios y la otra debe tener exponenciales complejos de números reales. Esto significa que, para cada unitario, podemos definir una matriz hermitiana correspondiente. Para ello simplemente reutilizamos los mismos eigenvalores, y utilizamos el <span class="math notranslate nohighlight">\(h_j\)</span> de cada <span class="math notranslate nohighlight">\(e^{ih_j}\)</span> como el eigenvalor correspondiente.</p>
<p>Del mismo modo, para cada matriz hermitiana existe un unitario. Simplemente reutilizamos los mismos estados propios, y exponenciamos los <span class="math notranslate nohighlight">\(h_j\)</span> para crear los valores propios <span class="math notranslate nohighlight">\(e^{ih_j}\)</span>. Esto se puede expresar como</p>
<div class="math notranslate nohighlight">
\[
U = e^{iH}
\]</div>
<p>Aquí hemos utilizado la definición estándar de cómo exponenciar una matriz, que tiene exactamente las propiedades que requerimos: preservar los estados propios y exponenciar los valores propios.</p>
</section>
<section id="pauli-decomposition-a-id-pauli-a">
<h3><span class="section-number">15.1.3. </span>2.3 Pauli decomposition <a id='pauli'></a><a class="headerlink" href="#pauli-decomposition-a-id-pauli-a" title="Permalink to this heading">#</a></h3>
<p>As we saw above, it is possible to write matrices entirely in terms of outer products.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M= \begin{pmatrix} m_{0,0}&amp;m_{0,1} \\ m_{1,0}&amp;m_{1,1} \end{pmatrix} = m_{0,0} |0\rangle\langle0|+ m_{0,1} |0\rangle\langle1|+ m_{1,0} |1\rangle\langle0|+ m_{1,1} |1\rangle\langle1|
\end{split}\]</div>
<p>Now we will see that it is also possible to write them completely in terms of Pauli operators. For this, the key thing to note is that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\frac{1+Z}{2} = \frac{1}{2}\left[ \begin{pmatrix} 1&amp;0 \\0&amp;1 \end{pmatrix}+\begin{pmatrix} 1&amp;0 \\0&amp;-1 \end{pmatrix}\right] = |0\rangle\langle0|,\\\frac{1-Z}{2} = \frac{1}{2}\left[ \begin{pmatrix} 1&amp;0 \\0&amp;1 \end{pmatrix}-\begin{pmatrix} 1&amp;0 \\0&amp;-1 \end{pmatrix}\right] = |1\rangle\langle1|
\end{split}\]</div>
<p>This shows that <span class="math notranslate nohighlight">\(|0\rangle\langle0|\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\langle1|\)</span> can be expressed using the identity matrix and <span class="math notranslate nohighlight">\(Z\)</span>. Now, using the property that <span class="math notranslate nohighlight">\(X|0\rangle = |1\rangle\)</span>, we can also produce</p>
<div class="math notranslate nohighlight">
\[\begin{split}
|0\rangle\langle1| = |0\rangle\langle0|X = \frac{1}{2}(1+Z)~X = \frac{X+iY}{2},\\\\
|1\rangle\langle0| = X|0\rangle\langle0| = X~\frac{1}{2}(1+Z) = \frac{X-iY}{2}.
\end{split}\]</div>
<p>Since we have all the outer products, we can now use this to write the matrix in terms of Pauli matrices:</p>
<div class="math notranslate nohighlight">
\[
M = \frac{m_{0,0}+m_{1,1}}{2}~1~+~\frac{m_{0,1}+m_{1,0}}{2}~X~+~i\frac{m_{0,1}-m_{1,0}}{2}~Y~+~\frac{m_{0,0}-m_{1,1}}{2}~Z.
\]</div>
<p>This example was for a general single-qubit matrix, but the corresponding result is true also for matrices for any number of qubits. We simply start from the observation that</p>
<div class="math notranslate nohighlight">
\[
\left(\frac{1+Z}{2}\right)\otimes\left(\frac{1+Z}{2}\right)\otimes\ldots\otimes\left(\frac{1+Z}{2}\right) = |00\ldots0\rangle\langle00\ldots0|,
\]</div>
<p>and can then proceed in the same manner as above. In the end it can be shown that any matrix can be expressed in terms of tensor products of Pauli matrices:</p>
<div class="math notranslate nohighlight">
\[
M = \sum_{P_{n-1},\ldots,P_0 \in \{1,X,Y,Z\}} C_{P_{n-1}\ldots,P_0}~~P_{n-1} \otimes P_{n-2}\otimes\ldots\otimes P_0.
\]</div>
<p>For Hermitian matrices, note that the coefficients <span class="math notranslate nohighlight">\(C_{P_{n-1}\ldots,P_0}\)</span> here will all be real.</p>
</section>
</section>
<section id="defining-universality-a-id-defining-a">
<h2><span class="section-number">15.2. </span>3. Defining Universality <a id='defining'></a><a class="headerlink" href="#defining-universality-a-id-defining-a" title="Permalink to this heading">#</a></h2>
<p>Just as each quantum gate can be represented by a unitary, so too can we describe an entire quantum computation by a (very large) unitary operation. The effect of this is to rotate the input state to the output state.</p>
<p>One possible special case of this is that the input and output states describe bit strings expressed in quantum form. The mapping of each input <span class="math notranslate nohighlight">\(x\)</span> to its output <span class="math notranslate nohighlight">\(f(x)\)</span> could be described by some (reversible) classical computation. Any such computation could therefore be expressed as a unitary.</p>
<div class="math notranslate nohighlight">
\[
U = \sum_x \left| f(x) \right\rangle \left\langle x \right|.
\]</div>
<p>If we were able to implement any possible unitary, it would therefore mean we could achieve universality in the sense of standard digital computers.</p>
<p>Another special case is that the input and output states could describe a physical system, and the computation we perform is to simulate the dynamics of that system. This is an important problem that is impractical for classical computers, but is a natural application of quantum computers. The time evolution of the system in this case corresponds to the unitary that we apply, and the associated Hermitian matrix is the Hamiltonian of the system. Achieving any unitary would therefore correspond to simulating any time evolution, and engineering the effects of any Hamiltonian.</p>
<p>Combining these insights we can define what it means for quantum computers to be universal. It is simply the ability to achieve any desired unitary on any arbitrary number of qubits. If we have this, we know that we can reproduce anything a digital computer can do, simulate any quantum system, and do everything else that is possible for a quantum computer.</p>
</section>
<section id="basic-gate-sets-a-id-basic-a">
<h2><span class="section-number">15.3. </span>4. Basic Gate Sets <a id='basic'></a><a class="headerlink" href="#basic-gate-sets-a-id-basic-a" title="Permalink to this heading">#</a></h2>
<p>Whether or not we can build any unitary from a set of basic gates depends greatly on what basic gates we have access to. For every possible realization of fault-tolerant quantum computing, there is a set of quantum operations that are most straightforward to realize. Often these consist of single- and two-qubit gates, most of which correspond to the set of so-called <em>Clifford gates</em>. This is a very important set of operations, which do a lot of the heavy-lifting in any quantum algorithm.</p>
<section id="clifford-gates-a-id-big-red-a">
<h3><span class="section-number">15.3.1. </span>4.1 Clifford Gates <a id='big-red'></a><a class="headerlink" href="#clifford-gates-a-id-big-red-a" title="Permalink to this heading">#</a></h3>
<p>To understand Clifford gates, let’s start with an example that you have already seen many times: the Hadamard.</p>
<div class="math notranslate nohighlight">
\[
H = |+\rangle\langle0|~+~ |-\rangle\langle1| = |0\rangle\langle+|~+~ |1\rangle\langle-|.
\]</div>
<p>This gate is expressed above using outer products, as described above. When expressed in this form, its famous effect becomes obvious: it takes <span class="math notranslate nohighlight">\(|0\rangle\)</span>, and rotates it to <span class="math notranslate nohighlight">\(|+\rangle\)</span>. More generally, we can say it rotates the basis states of the z measurement, <span class="math notranslate nohighlight">\(\{ |0\rangle,|1\rangle \}\)</span>, to the basis states of the x measurement, <span class="math notranslate nohighlight">\(\{ |+\rangle,|-\rangle \}\)</span>, and vice versa.</p>
<p>In this way, the effect of the Hadamard is to move information around a qubit. It swaps any information that would previously be accessed by an x measurement with that accessed by a z measurement.</p>
<p>The Hadamard can be combined with other gates to perform different operations, for example:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
H X H = Z,\\\\
H Z H = X.
\end{split}\]</div>
<p>By doing a Hadamard before and after an <span class="math notranslate nohighlight">\(X\)</span>, we cause the action it previously applied to the z basis states to be transferred to the x basis states instead. The combined effect is then identical to that of a <span class="math notranslate nohighlight">\(Z\)</span>. Similarly, we can create an <span class="math notranslate nohighlight">\(X\)</span> from Hadamards and a <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p>Similar behavior can be seen for the <span class="math notranslate nohighlight">\(S\)</span> gate and its Hermitian conjugate,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
S X S^{\dagger} = Y,\\\\
S Y S^{\dagger} = -X,\\\\
S Z S^{\dagger} = Z.
\end{split}\]</div>
<p>This has a similar effect to the Hadamard, except that it swaps <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> instead of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>. In combination with the Hadamard, we could then make a composite gate that shifts information between y and z.</p>
<p>This property of transforming Paulis into other Paulis is the defining feature of Clifford gates. Stated explicitly for the single-qubit case: if <span class="math notranslate nohighlight">\(U\)</span> is a Clifford and <span class="math notranslate nohighlight">\(P\)</span> is a Pauli, <span class="math notranslate nohighlight">\(U P U^{\dagger}\)</span> will also be a Pauli. For Hermitian gates, like the Hadamard, we can simply use <span class="math notranslate nohighlight">\(U P U\)</span>.</p>
<p>Further examples of single-qubit Clifford gates are the Paulis themselves. These do not transform the Pauli they act on. Instead, they simply assign a phase of <span class="math notranslate nohighlight">\(-1\)</span> to the two that they anticommute with. For example,</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Z X Z = -X,\\\\
Z Y Z = -Y,\\\\
Z Z Z= ~~~~Z.
\end{split}\]</div>
<p>You may have noticed that a similar phase also arose in the effect of the <span class="math notranslate nohighlight">\(S\)</span> gate. By combining this with a Pauli, we could make a composite gate that would cancel this phase, and swap <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> in a way more similar to the Hadamard’s swap of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p>For multiple-qubit Clifford gates, the defining property is that they transform tensor products of Paulis to other tensor products of Paulis. For example, the most prominent two-qubit Clifford gate is the CNOT. The property of this that we will make use of in this chapter is</p>
<div class="math notranslate nohighlight">
\[
{ CX}_{j,k}~ (X \otimes 1)~{ CX}_{j,k} = X \otimes X.
\]</div>
<p>This effectively ‘copies’ an <span class="math notranslate nohighlight">\(X\)</span> from the control qubit over to the target.</p>
<p>The process of sandwiching a matrix between a unitary and its Hermitian conjugate is known as conjugation by that unitary. This process transforms the eigenstates of the matrix, but leaves the eigenvalues unchanged. The reason why conjugation by Cliffords can transform between Paulis is because all Paulis share the same set of eigenvalues.</p>
</section>
<section id="non-clifford-gates-a-id-non-clifford-a">
<h3><span class="section-number">15.3.2. </span>4.2 Non-Clifford Gates <a id='non-clifford'></a><a class="headerlink" href="#non-clifford-gates-a-id-non-clifford-a" title="Permalink to this heading">#</a></h3>
<p>The Clifford gates are very important, but they are not powerful on their own. In order to do any quantum computation, we need gates that are not Cliffords. Three important examples are arbitrary rotations around the three axes of the qubit, <span class="math notranslate nohighlight">\(R_x(\theta)\)</span>, <span class="math notranslate nohighlight">\(R_y(\theta)\)</span> and <span class="math notranslate nohighlight">\(R_z(\theta)\)</span>.</p>
<p>Let’s focus on <span class="math notranslate nohighlight">\(R_x(\theta)\)</span>. As we saw above, any unitary can be expressed in an exponential form using a Hermitian matrix. For this gate, we find</p>
<div class="math notranslate nohighlight">
\[
R_x(\theta) = e^{i \frac{\theta}{2} X}.
\]</div>
<p>The last section also showed us that the unitary and its corresponding Hermitian matrix have the same eigenstates. In this section, we’ve seen that conjugation by a unitary transforms eigenstates and leaves eigenvalues unchanged. With this in mind, it can be shown that</p>
<div class="math notranslate nohighlight">
\[
U R_x(\theta)U^\dagger = e^{i \frac{\theta}{2} ~U X U^\dagger}.
\]</div>
<p>By conjugating this rotation by a Clifford, we can therefore transform it to the same rotation around another axis. So even if we didn’t have a direct way to perform <span class="math notranslate nohighlight">\(R_y(\theta)\)</span> and <span class="math notranslate nohighlight">\(R_z(\theta)\)</span>, we could do it with <span class="math notranslate nohighlight">\(R_x(\theta)\)</span> combined with Clifford gates. This technique of boosting the power of non-Clifford gates by combining them with Clifford gates is one that we make great use of in quantum computing.</p>
</section>
<section id="expanding-the-gate-set-a-id-expanding-a">
<h3><span class="section-number">15.3.3. </span>4.3 Expanding the Gate Set <a id='expanding'></a><a class="headerlink" href="#expanding-the-gate-set-a-id-expanding-a" title="Permalink to this heading">#</a></h3>
<p>As another example of combining <span class="math notranslate nohighlight">\(R_x(\theta)\)</span> with Cliffords, let’s conjugate it with a CNOT.</p>
<div class="math notranslate nohighlight">
\[
CX_{j,k} ~(R_x(\theta) \otimes 1)~ CX_{j,k} = CX_{j,k} ~ e^{i \frac{\theta}{2} ~ (X\otimes 1)}~ CX_{j,k} = e^{i \frac{\theta}{2} ~CX_{j,k} ~ (X\otimes 1)~ CX_{j,k}} = e^{i \frac{\theta}{2} ~ X\otimes X}
\]</div>
<p>This transforms our simple, single-qubit rotation into a much more powerful two-qubit gate. This is not just equivalent to performing the same rotation independently on both qubits. Instead, it is a gate capable of generating and manipulating entangled states.</p>
<p>We needn’t stop there. We can use the same trick to extend the operation to any number of qubits. All that’s needed is more conjugates by the CNOT to keep copying the <span class="math notranslate nohighlight">\(X\)</span> over to new qubits.</p>
<p>Furthermore, we can use single-qubit Cliffords to transform the Pauli on different qubits. For example, in our two-qubit example we could conjugate by <span class="math notranslate nohighlight">\(S\)</span> on the qubit on the right to turn the <span class="math notranslate nohighlight">\(X\)</span> there into a <span class="math notranslate nohighlight">\(Y\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\left( I \otimes S \right)  ~e^{i \frac{\theta}{2} ~ X\otimes X}~\left( I \otimes S^\dagger \right) = e^{i \frac{\theta}{2} ~ X\otimes Y}.
\]</div>
<p>With these techniques, we can make complex entangling operations that act on any arbitrary number of qubits, of the form</p>
<div class="math notranslate nohighlight">
\[
U = e^{i\frac{\theta}{2} ~ P_{n-1}\otimes P_{n-2}\otimes...\otimes P_0}, ~~~ P_j \in \{I,X,Y,Z\}.
\]</div>
<p>This all goes to show that combining the single and two-qubit Clifford gates with rotations around the x axis gives us a powerful set of possibilities. What’s left to demonstrate is that we can use them to do anything.</p>
</section>
</section>
<section id="proving-universality-a-id-proving-a">
<h2><span class="section-number">15.4. </span>5. Proving Universality <a id='proving'></a><a class="headerlink" href="#proving-universality-a-id-proving-a" title="Permalink to this heading">#</a></h2>
<p>As for classical computers, we will need to split this big job up into manageable chunks. We’ll need to find a basic set of gates that will allow us to achieve this. As we’ll see, the single- and two-qubit gates of the last section are sufficient for the task.</p>
<p>Suppose we wish to implement the unitary</p>
<div class="math notranslate nohighlight">
\[
U = e^{i(aX + bZ)},
\]</div>
<p>but the only gates we have are <span class="math notranslate nohighlight">\(R_x(\theta) = e^{i \frac{\theta}{2} X}\)</span> and <span class="math notranslate nohighlight">\(R_z(\theta) = e^{i \frac{\theta}{2} Z}\)</span>. The best way to solve this problem would be to use Euler angles. But let’s instead consider a different method.</p>
<p>The Hermitian matrix in the exponential for <span class="math notranslate nohighlight">\(U\)</span> is simply the sum of those for the <span class="math notranslate nohighlight">\(R_x(\theta)\)</span> and <span class="math notranslate nohighlight">\(R_z(\theta)\)</span> rotations. This suggests a naive approach to solving our problem: we could apply <span class="math notranslate nohighlight">\(R_z(2b) = e^{i bZ}\)</span> followed by <span class="math notranslate nohighlight">\(R_x(2a) = e^{i a X}\)</span>. Unfortunately, because we are exponentiating matrices that do not commute, this approach will not work.</p>
<div class="math notranslate nohighlight">
\[
e^{i a X} e^{i b Z} \neq e^{i(aX + bZ)}
\]</div>
<p>However, we could use the following modified version:</p>
<div class="math notranslate nohighlight">
\[
U = \lim_{n\rightarrow\infty} ~ \left(e^{iaX/n}e^{ibZ/n}\right)^n.
\]</div>
<p>Here we split <span class="math notranslate nohighlight">\(U\)</span> up into <span class="math notranslate nohighlight">\(n\)</span> small slices. For each slice, it is a good approximation to say that</p>
<div class="math notranslate nohighlight">
\[
e^{iaX/n}e^{ibZ/n} = e^{i(aX + bZ)/n}
\]</div>
<p>The error in this approximation scales as <span class="math notranslate nohighlight">\(1/n^2\)</span>. When we combine the <span class="math notranslate nohighlight">\(n\)</span> slices, we get an approximation of our target unitary whose error scales as <span class="math notranslate nohighlight">\(1/n\)</span>. So by simply increasing the number of slices, we can get as close to <span class="math notranslate nohighlight">\(U\)</span> as we need. Other methods of creating the sequence are also possible to get even more accurate versions of our target unitary.</p>
<p>The power of this method is that it can be used in complex cases than just a single qubit. For example, consider the unitary</p>
<div class="math notranslate nohighlight">
\[
U = e^{i(aX\otimes X\otimes X + bZ\otimes Z\otimes Z)}.
\]</div>
<p>We know how to create the unitary <span class="math notranslate nohighlight">\(e^{i\frac{\theta}{2} X\otimes X\otimes X}\)</span> from a single qubit <span class="math notranslate nohighlight">\(R_x(\theta)\)</span> and two controlled-NOTs.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>With a few Hadamards, we can do the same for <span class="math notranslate nohighlight">\(e^{i\frac{\theta}{2} Z\otimes Z\otimes Z}\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives us the ability to reproduce a small slice of our new, three-qubit <span class="math notranslate nohighlight">\(U\)</span>:</p>
<div class="math notranslate nohighlight">
\[
e^{iaX\otimes X\otimes X/n}e^{ibZ\otimes Z\otimes Z/n} = e^{i(aX\otimes X\otimes X + bZ\otimes Z\otimes Z)/n}.
\]</div>
<p>As before, we can then combine the slices together to get an arbitrarily accurate approximation of <span class="math notranslate nohighlight">\(U\)</span>.</p>
<p>This method continues to work as we increase the number of qubits, and also the number of terms that need simulating. Care must be taken to ensure that the approximation remains accurate, but this can be done in ways that require reasonable resources. Adding extra terms to simulate, or increasing the desired accuracy, only require the complexity of the method to increase polynomially.</p>
<p>Methods of this form can reproduce any unitary <span class="math notranslate nohighlight">\(U = e^{iH}\)</span> for which <span class="math notranslate nohighlight">\(H\)</span> can be expressed as a sum of tensor products of Paulis. Since we have shown previously that all matrices can be expressed in this way, this is sufficient to show that we can reproduce all unitaries. Though other methods may be better in practice, the main concept to take away from this chapter is that there is certainly a way to reproduce all multi-qubit unitaries using only the basic operations found in Qiskit. Quantum universality can be achieved!</p>
<p>This gate set is not the only one that can achieve universality. For example it can be shown that just the Hadamard and Toffoli are sufficient for universality. Multiple other gates sets have also been considered and been proven universal, each motivated by different routes toward achieving the gates fault-tolerantly.</p>
<p>Everything we have discussed in this book follows the circuit model of computation. However, the circuit model is not the only universal model of quantum computation. Other forms of quantum computation such as adiabatic quantum computing or measurement based quantum computing exist. The fact that they are universal means that it has been proven that there is a mapping in polynomial time and resources from the circuit model to these other models of computation. These other models often leverage other quantum mechanical properties in order to perform their computation. While these other forms of quantum computation exist, it is important to note that the benefits of each concern only physical and hardware problems. Since a universal model of quantum computation can perform any quantum algorithm, we need only stick with the circuit model and can ignore other universal models for our discussion.</p>
<p>There are other forms of quantum computation that are not universal, but are applicable to specific applications. For example quantum annealing may be useful for optimization and sampling problems. Annealing is the process of heating a metal to a high temperature and then allowing it to cool down slowly. This process causes molten metal to flow over the surface of the metal piece and redistribute itself; changing many properties of the metal in question. Quantum annealing is analogous to the physical process of annealing in some sense. It involves encoding problems into an energy landscape of sorts and then letting a quantum state explore the landscape. While normal waves may get trapped in troughs which are lower than their surroundings (local minima), quantum effects increase the speed at which the quantum states find the true lowest point on the landscape (global minima).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="o">%</span><span class="k">qiskit_version_table</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><h3>Version Information</h3><table><tr><th>Software</th><th>Version</th></tr><tr><td><code>qiskit</code></td><td>0.44.2</td></tr><tr><td><code>qiskit-terra</code></td><td>0.25.2</td></tr><tr><th colspan='2'>System information</th></tr><tr><td>Python version</td><td>3.11.4</td></tr><tr><td>Python compiler</td><td>MSC v.1916 64 bit (AMD64)</td></tr><tr><td>Python build</td><td>main, Jul  5 2023 13:38:37</td></tr><tr><td>OS</td><td>Windows</td></tr><tr><td>CPUs</td><td>4</td></tr><tr><td>Memory (Gb)</td><td>11.799663543701172</td></tr><tr><td colspan='2'>Tue Oct 24 10:15:52 2023 Hora de verano romance</td></tr></table></div></div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./jupyters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="Tema6_more-circuit-identities.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">14. </span>Más ciruitos cuánticos</p>
      </div>
    </a>
    <a class="right-next"
       href="Tema8_QFT.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">16. </span>Transformada cuántica de Fourier</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#operaciones-con-matrices-a-id-fun-a">15.1. Operaciones con matrices <a id="fun"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-como-outer-products-a-id-outer-a">15.1.1. Matrices como outer products <a id="outer"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#matrices-unitarias-y-hermitianas-a-id-u-and-h-a">15.1.2. Matrices Unitarias y Hermitianas. <a id="u-and-h"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pauli-decomposition-a-id-pauli-a">15.1.3. 2.3 Pauli decomposition <a id="pauli"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#defining-universality-a-id-defining-a">15.2. 3. Defining Universality <a id="defining"></a></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-gate-sets-a-id-basic-a">15.3. 4. Basic Gate Sets <a id="basic"></a></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clifford-gates-a-id-big-red-a">15.3.1. 4.1 Clifford Gates <a id="big-red"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#non-clifford-gates-a-id-non-clifford-a">15.3.2. 4.2 Non-Clifford Gates <a id="non-clifford"></a></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#expanding-the-gate-set-a-id-expanding-a">15.3.3. 4.3 Expanding the Gate Set <a id="expanding"></a></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#proving-universality-a-id-proving-a">15.4. 5. Proving Universality <a id="proving"></a></a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Francisco Rodríguez
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>